### ProctoSaurus

This project is related to Thesaurus of the Gods, and in some ways is an
explanation of it. The TotG program takes a template message text file and
an indexed list of potential substitute words (like a thesaurus) and for
every message word it finds in the index, it selects a replacement word. The
output text with these replacements resembles the template text file to an
extent determined by the indexed "saurus" file of substitution lists. A
version of the TotG program can produce a "chain" file which captures the
relationship between template message text and saurus index.

### What Does It Do?

The ProctoSaurus repository programs support hidden data in Thesaurus of the
Gods text files. This information is located in the **structure** of the
text file, and is not visible except through the application of these tools.
After storing the message information with the ProctoSaurus tools, the
original data can be safely deleted and all other traces can be wiped away.
The hidden information can be recovered from the Thesaurus of the Gods
output at a later time, or the relatively innocuous text can be sent as an
ordinary email or social media post. Although it may appear to be senseless
chatty gibberish, it is not immediately obvious that the hidden message is
present.

### How Does It Work?

The TotG program can be directed to select replacements at random or the
substitutions can be guided by an input chain file. When a chain file is
used it completely determines each substitution whenever an indexed saurus
word is encountered in the template message text. As a consequence of this,
the output substitution text can be read by the TotG version that generates
a chain file, and the chain will be identical to the one used to guide the
substitution process. In effect the chain sequence can be communicated
indirectly between TotG sessions which share the saurus file. Only the
output substitution text need be transmit between the two sessions. The
originator can delete the chain after creating the output text, and a new
copy of the chain can be regenerated by the receiver using the output text
alone.

Information can be encoded in the chain, used to guide a template message
substitution, then subsequently recovered from the output substitution text.
Such information communication can be used between physically remote
parties, or simply between two sessions at different times. The text page of
a private diary, for example, might be encoded in a chain, then used to
create a substitution from a bland message like a grocery list or meeting
schedule and stored among many other files of a similar appearance. The
chain is then deleted, but can be recovered at any time by anyone who knows
which text is the output substitution and what saurus file was used.
Furthermore, a meaningless chain can be extracted from a genuine grocery
list, meeting schedule, or the like, using any saurus you may care to
choose. It may be a challenging problem for an eavesdropper to recognize
the genuine article in a directory full of similar files. Since all text
files have a (probably meaningless) chain interpretation in some saurus
context, a certain plausible deniability is implied.

### What's In This Repository?

The chain has an associated numeric formalism that is an interpretation as a 
unique, though usually very large number. A very important part of the present
ProctoSaurus project in this repository is the Proctosaurus.dvi or
ProctoSaurus.pdf documents, which were created using the LaTex graphical
typesetting program for mathematical notation. The math is not hard. It's
really just the fundamental theorem of arithmetic used in a way you might
not have seen. There is some very juicy and harder stuff that uses these
concepts, but that will all happen in another time and place, not here. 

The C code is not hard. If you haven't encountered them before, the big
numbers look pretty wild, but it's just because they are big. It enhances
the coolness factor somehow. These big integers are made easy by the
excellent GNU Multi-Precision (GMP) library which you should definitely
get acquainted with if you are not already using it. The only thing that
might be a little tricky if you are not used to it is that you must remember
to initialize your GMP variables before you use them. Your mama told you to
do that in C++ anyway, right? OK. Easy.

There is very little code here, and most of it is compilable, runnable
examples in support of the explanations in the DVI/PDF file. This code
refers to the Thesaurus of the Gods code for the more complete examples.
There are example template message and saurus files in the Thesaurus of
the Gods repository that are used as examples here, also. Until you are
ready to look at the examples (which may not even interest everyone) you
should look through the ProctoSaurus DVI/PDF file. I wouldn't say it is
conceptually dependent on the Thesaurus of the Gods materials.

A little imagination takes you a long way. My intention here is to provide
almost trivial application code that clearly illustrates the main ideas.
Like the Thesaurus of the Gods code, it is intentionally simple and
free-standing other than the dependence on the GMP library. It is primarily
made to be read by programmers and beat upon and hacked and filled with
print statements and the like. Any basic Unix-like distro should work fine
with minimal or no modification. A common Linux with gcc should do the
trick. The GMP library contains substantial assembly language components,
but the range of architectures supported is surprisingly broad. It builds
easily with the usual Configure/Make steps, but is included in many Linux
distros as an optional component. You might be able to apt-get it, or
whatever, as a quick binary install if it is not already available on your
machine.

My source files are very generic C. I work almost exclusively on Linux these
days using GCC, but the most I would expect to do on another system is
change a few configuration settings or rearrange the header files.

### A Brief Description of the Source Code Files

There is a small program called ChainToNum.c that reads a chain file, such
as the one produced in the examples in Thesaurus of the Gods, converts it
to a single numeric value, and displays that on stdout. It is a more
complete version of the code fragment 2 in the ProctoSaurus DVI/PDF
document. It is compilable and runnable.

A similar stand-alone program called NumToChain reads a chain and a number
then replaces the numeric value in the chain with the numeric value given
and writes this new chain to stdout. It is a complete compilable and
runnable example of code fragment 4 in the ProctoSaurus DVI/PDF document.

The file CalcCapacity.c is a reduced version of ChainToNum.c, but was
separated as a convenience, since the capacity of the chain is the only item
of interest. It refers to code fragment 7 in the DVI/PDF document.

A very small program called RanDigits.c generates a string of psuedo-random
decimal digits, in case you may want to look at a variety of random cases.
There are two command line parameters. The first is the number of decimal
digits desired (default is 335). The second is a random seed value, in case
you want to make a repeatable output sequence. I can be handy in practical
situations to use this program to specify two small numbers to get a large
number without the need to store that number after using it. If no
psuedo-random seed is specified the RanDigits program reads the low digits
of the system clock and uses that as the seed.

Another small example program is called TextToNum.c. It reads a text string
from the command line, converts it to a big number and prints that value as
a decimal number to stdout. This is a compilable, runnable stand alone
program demonstrating code fragment 5 of the DVI/PDF document. As usual, -p
prints a few messages at run time, no parameters or just a text string (in
quotes) on the command line does the conversion and prints only the
resulting number.

Similarly, NumToText with a number on the command line attempts to interpret
it as the numeric representation of a text string. If it is a number that
does not have the properties of a base 128 conversion like the one made by
the TextToNum program, an appropriate message is printed. Of course, it is
related to code fragment 6 in the DVI/PDF document. This little program,
along with th rest of the code, is just a hackable demo of how these
concepts work. As such, it is intended to be compatible with th other bits
of demo code. It is not the industrial version that you are going to write
(I'm confident). It doesn't handle embedded carriage returns, quotes, and
such like. I'm sure even your first hack will do all that.

If a number doesn't have the simple base-128 representation structure it
won't transform back into a text string. Since this is a fairly easy way for
an eavesdropper to look for hidden text strings, especially strings that are
shorter than the chain capacity, an additional simple measure is to perform
a logical XOR with another (possibly larger) number before packing it into a
chain. The program CombineNum.c provides a way to do this. There are many
possibilities, naturally. That is what makes it harder to analyze. The
obvious one that uses the simple tools in this repo is to combine the
numeric value of your text with a sequence of psuedo-random digits
generated with the RanDigits program and using an easily remembered number
of digits and psuedo-random seed - for example: ./RanDigits 100 666
followed by ./CombineNum with your converted text and the output from
RanDigits. You can throw away the random string, as long as you are sure to
remember the number of digits and the seed value you used. A word of caution
about the RNG. This code calls the C library functions srand() and rand(),
which are not everywhere identical. An industrial version would call its own
code to provide these functions. I see no need to go there in this
exposition. There are plenty of great discussions and many sources of code
for this. As I dimly recall, even the Wikipedia page on RNG shows the
details of some common Unix and MS RNGs.


